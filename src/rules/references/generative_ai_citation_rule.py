"""
This file implements the GenerativeAiCitationRule for the writing style linter.
It focuses on codifying the guidelines for citing content from generative AI models
as described in the Style Guide.

The rule uses pure spaCy morphological analysis and linguistic anchors to identify
incomplete citations for generative AI tools.
"""

import re
from typing import List, Dict, Any

# Handle imports for different contexts
try:
    from ..base_rule import BaseRule
except ImportError:
    from base_rule import BaseRule


class GenerativeAiCitationRule(BaseRule):
    """
    Checks for proper citation when referencing content generated by AI models.
    """
    def __init__(self):
        super().__init__()

    def _get_rule_type(self) -> str:
        return "citations_generative_ai"

    def analyze(self, text: str, sentences: List[str], nlp=None) -> List[Dict[str, Any]]:
        """
        Analyzes the text for improper citations of generative AI models.

        Args:
            text: The full text to analyze.
            sentences: A list of sentences from the text.
            nlp: A loaded spaCy NLP model, passed from the main application.

        Returns:
            A list of dictionaries, where each dictionary represents a found error.
        """
        if not nlp:
            return []
            
        errors = []
        for i, sentence in enumerate(sentences):
            if not sentence.strip():
                continue
            
            doc = nlp(sentence)
            errors.extend(self._check_improper_ai_citation(doc, sentence, i))
            
        return errors

    def _detect_ai_model_references(self, doc):
        """
        Uses morphological analysis to detect AI model references.
        """
        ai_indicators = []
        
        # Morphological Analysis: Look for AI-related patterns
        ai_keywords = {'ai', 'gpt', 'chatgpt', 'claude', 'gemini', 'dall-e', 'midjourney', 'stable', 'diffusion'}
        tech_companies = {'openai', 'google', 'anthropic', 'microsoft', 'meta'}
        
        for token in doc:
            # Check for AI model naming patterns (often contain numbers/versions)
            if (token.lemma_.lower() in ai_keywords or 
                any(keyword in token.text.lower() for keyword in ai_keywords)):
                ai_indicators.append(token)
                continue
                
            # Check for compound AI terms (like "stable diffusion")
            if token.lemma_.lower() in {'stable', 'generative'} and token.i + 1 < len(doc):
                next_token = doc[token.i + 1]
                if next_token.lemma_.lower() in {'diffusion', 'ai', 'model'}:
                    ai_indicators.append(token)
                    continue
        
        # Check named entities for AI companies
        for ent in doc.ents:
            if (ent.label_ in ['ORG', 'PRODUCT'] and 
                ent.text.lower() in tech_companies):
                ai_indicators.append(ent[0])
                
        return ai_indicators

    def _check_improper_ai_citation(self, doc, sentence: str, sentence_index: int) -> List[Dict[str, Any]]:
        """
        Identifies mentions of AI models and checks if the citation is complete.
        Rule: A citation must include company, model, version, date, and prompt.
        """
        issues = []
        
        # Linguistic Anchor: Use morphological analysis to detect AI model references
        ai_references = self._detect_ai_model_references(doc)
        
        if not ai_references:
            return []

        # For each AI reference found, check citation completeness
        for ai_token in ai_references:
            # Morphological & Contextual Analysis: Check for required citation components.
            has_company = self._check_for_company_mention(doc)
            has_version = self._check_for_version_info(doc)
            has_date = any(e.label_ == 'DATE' for e in doc.ents)
            has_prompt_citation = self._check_for_prompt_citation(doc)

            # If all components are not present, flag an error.
            if not (has_company and has_date and has_prompt_citation):
                message = f"Incomplete citation for the generative AI model '{ai_token.text}'."
                suggestion = 'When citing a generative AI model, include the company, model name, version (if any), date, and the specific prompt used. Example: OpenAI, ChatGPT-4, response to prompt "Explain...", 12 March 2025.'
                issues.append(self._create_error(
                    sentence=sentence,
                    sentence_index=sentence_index,
                    message=message,
                    suggestions=[suggestion],
                    severity="high",
                    violating_token=ai_token.text
                ))
                break  # One error per sentence is sufficient
                
        return issues
    
    def _check_for_company_mention(self, doc) -> bool:
        """Uses morphological analysis to detect company mentions."""
        # Check for named entities marked as organizations
        for ent in doc.ents:
            if ent.label_ == 'ORG':
                return True
        
        # Check for capitalized company-like tokens
        for token in doc:
            if (token.is_title and not token.is_sent_start and 
                token.pos_ in ['NOUN', 'PROPN'] and 
                len(token.text) > 3):
                return True
        return False
    
    def _check_for_version_info(self, doc) -> bool:
        """Uses morphological analysis to detect version information."""
        for token in doc:
            # Version numbers often contain digits
            if token.like_num or (token.text.isalnum() and not token.is_alpha):
                return True
            # Version patterns like "v1.0" or "version 4"
            if token.lemma_.lower() in ['version', 'v'] and token.i + 1 < len(doc):
                if doc[token.i + 1].like_num:
                    return True
        return False
    
    def _check_for_prompt_citation(self, doc) -> bool:
        """Uses dependency parsing to detect proper prompt citations."""
        for i, token in enumerate(doc):
            if token.lemma_.lower() == "prompt":
                # Check for "response to prompt" structure
                if (i > 1 and doc[i-1].lemma_.lower() == "to" and 
                    doc[i-2].lemma_.lower() == "response"):
                    # Look for quotation following the prompt mention
                    for j in range(i+1, min(len(doc), i+5)):
                        if doc[j].is_quote or doc[j].text in ['"', "'"]:
                            return True
        return False
